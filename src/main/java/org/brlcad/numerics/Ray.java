/* Generated by Together */

package org.brlcad.numerics;

import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;


/**
 * Ray.
 * <p>
 * <b>Source:</b>
 * <p>
 * The U. S. Army Research Laboratory Aberdeen Proving Ground, Maryland 21005
 * USA
 * </p>
 * <p>
 * <b>Copyright Notice:</b>
 * <p>
 * This software is Copyright (C) 2004 by the United States Army. All rights
 * reserved.
 * </p>
 * <p/>
 * <b>Responsibilities:</b>
 * <ul>
 * <li>Represents a 3D ray.</li>
 * </ul>
 * <p/>
 * <b>Collaboration:</b>
 * <ul>
 * <li>Uses a Point and Vector3.</li>
 * </ul>
 */
public class Ray implements Externalizable {

    static final long serialVersionUID = -6058668611916514230L;

    private Point start;

    private Vector3 direction;

    /**
     * No arg constructor for use by Externalization. DO NOT USE THIS CONSTRUCTOR
     */
    public Ray() {
    }

    /**
     * Construct a Ray from a Point and a Vector3. New Point and Vector3 are
     * created to keep this Ray independent
     *
     * @param s The starting Point of the Ray
     * @param d The direction vector of the Ray
     */
    public Ray(Point s, Vector3 d) {
        if (s == null || !Point.isValidTriple(s)) {
            throw new IllegalArgumentException(
                    "Point for Ray constructor either null or not valid. Point = " + s);
        }
        if (d == null || !Vector3.isValidTriple(d)
                || d.magnitude() < Triple.INITIAL_TOLERANCE) {
            throw new IllegalArgumentException(
                    "Vector for Ray constructor either null, not valid, or vector magnitude is near zero. Vector = " + d);
        }
        start = new Point(s);
        direction = new Vector3(d);
    }

    /**
     * Produce a String representation of the Ray of the form "start: (x, y, z),
     * direction: (x, y, z)"
     *
     * @return A String with the expected values
     */
    @Override
    public String toString() {
        return "start: " + start + ", direction: " + direction;
    }

    /**
     * Get the start point of this Ray
     *
     * @return The start Point of this Ray
     */
    public Point getStart() {
        return (start);
    }

    /**
     * Get the direction vector for this Ray
     *
     * @return The direction Vector3 for this Ray
     */
    public Vector3 getDirection() {
        return (direction);
    }

    /**
     * Test equality of rays.
     *
     * @param r Ray to compare against.
     * @return if they're equal.
     */
    public boolean isEqual(Ray r) {
        if (r == null || !Ray.isValidRay(r)) {
            throw new IllegalArgumentException(
                    "isEqual() called with Ray that is either null or not valid");
        }
        return (start.isEqual(r.getStart()) && direction.isEqual(r
                .getDirection()));
    }

    /**
     * Test equality of rays.
     *
     * @param p1 A ray.
     * @param p2 The ray to compare p1 against.
     * @return if they're equal.
     */
    public static boolean isEqual(Ray p1, Ray p2) {
        if (p1 == null && p2 == null) {
            return true;
        }
        if (p1 == null || p2 == null) {
            return false;
        }

        return p1.isEqual(p2);
    }

    /**
     * Reviews the point and vector portions of a ray to ensure that none are
     * null. Also reviews the internal values of the point and vector to ensure
     * none are Infinity or Not-A-Number (NaN).
     *
     * @param r Input ray
     * @return true, if the ray is valid
     */
    public static boolean isValidRay(Ray r) {
        return !(r == null || r.start == null || !Point.isValidTriple(r.start)
                || r.direction == null || !Vector3.isValidTriple(r.direction)
                || r.direction.magnitude() < Triple.INITIAL_TOLERANCE);
    }

    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeDouble(start.getX());
        out.writeDouble(start.getY());
        out.writeDouble(start.getZ());
        out.writeDouble(direction.getX());
        out.writeDouble(direction.getY());
        out.writeDouble(direction.getZ());
    }

    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
        start = new Point(in.readDouble(), in.readDouble(), in.readDouble());
        direction = new Vector3(in.readDouble(), in.readDouble(), in.readDouble());
    }
}
