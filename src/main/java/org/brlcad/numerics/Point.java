/* Generated by Together */

package org.brlcad.numerics;

import java.io.Serializable;
import javax.measure.unit.SI;
import javax.measure.unit.Unit;


/**
 * Point. <p/> <p/> <b>Source:</b> <p/>
 * <p>
 * The U. S. Army Research Laboratory Aberdeen Proving Ground, Maryland 21005
 * USA
 * </p>
 * <p/> <p/> <p/> <b>Copyright Notice:</b> <p/>
 * <p>
 * This software is Copyright (C) 2004 by the United States Army. All rights
 * reserved.
 * </p>
 * <p/> <p/> <p/> <b>Responsibilities:</b>
 * <ul>
 * <li>Represents a 3D point in millimeters</li>
 * </ul>
 */

public class Point extends Triple implements Serializable {

    static final long serialVersionUID = 6928788732940688042L;

    // points must always be in millimeters
    public static Unit pointUnits = SI.MILLI(SI.METER);


    /**
     * No argument constructor to support JavaBeans
     */
    public Point() {
    }

    /**
     * Construct a Point from 3 coordinates
     *
     * @param x_in The X coordinate in millimeters
     * @param y_in The Y coordinate in millimeters
     * @param z_in The Z coordinate in millimeters
     */
    public Point(double x_in, double y_in, double z_in) {
//        if (Double.isInfinite(x_in) || Double.isNaN(x_in)) {
//            throw new IllegalArgumentException(
//                    "Illegal x value for Point coordinates: " + x_in);
//        }
//        if (Double.isInfinite(y_in) || Double.isNaN(y_in)) {
//            throw new IllegalArgumentException(
//                    "Illegal y value for Point coordinates: " + y_in);
//        }
//        if (Double.isInfinite(z_in) || Double.isNaN(z_in)) {
//            throw new IllegalArgumentException(
//                    "Illegal z value for Point coordinates: " + z_in);
//        }

        x = x_in;
        y = y_in;
        z = z_in;
        mag = Double.NaN;
    }

    /**
     * Construct a Point from another Point (i.e., copy constructor)
     *
     * @param p The point to copy
     */
    public Point(Point p) {
        if (p == null) {
            throw new IllegalArgumentException(
                    "Cannot construct a Point from a null Point");
        }
//        if (!isValidTriple(p)) {
//            throw new IllegalArgumentException(
//                    "Cannot construct a Point from Point with illegal coordinates");
//        }

        x = p.x;
        y = p.y;
        z = p.z;
        mag = Double.NaN;
    }

    /**
     * Factory for a Point constructed from a Position
     *
     * @param p The Position
     * @return a Point representing the Position (units of millimeters)
     */
    public static Point fromPosition(Position p) {
        return new Point(p.getPositionX().doubleValue(units), p.getPositionY().doubleValue(units), p.getPositionZ().doubleValue(units));
    }

    /**
     * Create a Vector from the origin to this Point
     *
     * @return The new Vector object
     */
    public Vector3 toVector() {
        return new Vector3(x, y, z);
    }

    /**
     * Calculate the distance between this point and another point.
     *
     * @param p The other point
     * @return Distance between the points
     */
    public double dist(Point p) {
        if (p == null) {
            throw new IllegalArgumentException(
                    "Cannot calculate distance to a null Point");
        }
//        if (!isValidTriple(p)) {
//            throw new IllegalArgumentException(
//                    "Cannot calculate distance from Point with illegal coordinates");
//        }

        return Math.sqrt(((x - p.x) * (x - p.x)) + ((y - p.y) * (y - p.y))
                + ((z - p.z) * (z - p.z)));
    }

    /**
     * Test equality of points.
     *
     * @param o Object that may or may not be a point.
     * @return true if 'o' is a point and the points are in the same place,
     *         within the tolerance of 'this'.
     */
    @Override
    public boolean equals(Object o) {
        if (o instanceof Point) {
            return isEqual((Point) o);
        }
        return false;
    }

    /**
     * Move this point by the amount specified by the supplied input Vector
     *
     * @param vector Input vector
     */
    public void translate(Vector3 vector) {
        if (vector == null) {
            throw new IllegalArgumentException(
                    "Cannot translate with a null translation vector");
        }
        if (!Vector3.isValidTriple(vector)) {
            throw new IllegalArgumentException(
                    "Cannot translate using Vector3 with illegal coordinates");
        }

        x += vector.getX();
        y += vector.getY();
        z += vector.getZ();
        mag = Double.NaN;
    }

    /**
     * Rotate this vector around the specified up vector.
     *
     * @param upVector The up vector to perform rotation around.
     * @param angle    The angle (in degrees) to rotate the vector.
     * @throws IllegalArgumentException if the the vector is null, any one of
     *                                  the vector's coordinates is either NaN or Infinite, or the
     *                                  rotation angle is either NaN or Infinite.
     */
    public void rotate(Vector3 upVector, double angle) {
        if (upVector == null) {
            throw new IllegalArgumentException(
                    "rotate() called with null upVector");
        }
//        if (!Vector3.isValidTriple(upVector)) {
//            throw new IllegalArgumentException(
//                    "rotate() called with upVector containing NaN/Infinity coordinates");
//        }

        if (Double.isInfinite(angle) || Double.isNaN(angle)) {
            throw new IllegalArgumentException(
                    "rotate() called with illegal angle: " + angle);
        }

        // create basis vectors with upVector as one of the directions
        Vector3 v3 = new Vector3(upVector);
        v3.normalize();

        Vector3 v0 = this.toVector();
        Vector3 v1 = v0.crossProduct(v3);
        v1.normalize();

        if (Double.isNaN(v1.getX()) || Double.isNaN(v1.getY())
                || Double.isNaN(v1.getZ())) {
            // this vector is parallel to the upvector, no need to change it
            return;
        }

        Vector3 v2 = Vector3.crossProduct(v3, v1);
        v2.normalize();

        double radians = angle / 180.0 * java.lang.Math.PI;
        double sine = Math.sin(radians);
        double cosine = Math.cos(radians);

        double x1 = v0.dotProduct(v1);
        double y1 = v0.dotProduct(v2);
        double z1 = v0.dotProduct(v3);

        double x2 = x1 * cosine - y1 * sine;
        double y2 = x1 * sine + y1 * cosine;

        this.x = 0.0;
        this.y = 0.0;
        this.z = 0.0;

        this.join(x2, v1);
        this.join(y2, v2);
        this.join(z1, v3);
    }
}
