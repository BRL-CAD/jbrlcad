/* Generated by Together */

package org.brlcad.numerics;

import javax.measure.unit.SI;
import javax.measure.unit.Unit;
import java.io.Serializable;
import static java.lang.Math.abs;
import static java.lang.Math.sqrt;

/**
 * Point. <p/> <p/> <b>Source:</b> <p/>
 * <p>
 * The U. S. Army Research Laboratory Aberdeen Proving Ground, Maryland 21005
 * USA
 * </p>
 * <p/> <p/> <p/> <b>Copyright Notice:</b> <p/>
 * <p>
 * This software is Copyright (C) 2004 by the United States Army. All rights
 * reserved.
 * </p>
 * <p/> <p/> <p/> <b>Responsibilities:</b>
 * <ul>
 * <li>Represents a 3D point in millimeters</li>
 * </ul>
 */

public class Point implements Serializable {

    static final long serialVersionUID = 6928788732940688041L;

    private static final double INITIAL_TOLERANCE = 1.0E-11;

    // points must always be in millimeters
    public static Unit pointUnits = SI.MILLI(SI.METER);

    private double tolerance = INITIAL_TOLERANCE;

    private double x = 0.0;

    private double y = 0.0;

    private double z = 0.0;

    /**
     * No argument constructor to support JavaBeans
     */
    public Point() {
    }

    /**
     * Construct a Point from 3 coordinates
     *
     * @param x_in The X coordinate in millimeters
     * @param y_in The Y coordinate in millimeters
     * @param z_in The Z coordinate in millimeters
     */
    public Point(double x_in, double y_in, double z_in) {
//        if (Double.isInfinite(x_in) || Double.isNaN(x_in)) {
//            throw new IllegalArgumentException(
//                    "Illegal x value for Point coordinates: " + x_in);
//        }
//        if (Double.isInfinite(y_in) || Double.isNaN(y_in)) {
//            throw new IllegalArgumentException(
//                    "Illegal y value for Point coordinates: " + y_in);
//        }
//        if (Double.isInfinite(z_in) || Double.isNaN(z_in)) {
//            throw new IllegalArgumentException(
//                    "Illegal z value for Point coordinates: " + z_in);
//        }

        x = x_in;
        y = y_in;
        z = z_in;
    }

    /**
     * Construct a Point from another Point (i.e., copy constructor)
     *
     * @param p The point to copy
     */
    public Point(Point p) {
        if (p == null) {
            throw new IllegalArgumentException(
                    "Cannot construct a Point from a null Point");
        }
//        if (!isValidPoint(p)) {
//            throw new IllegalArgumentException(
//                    "Cannot construct a Point from Point with illegal coordinates");
//        }

        x = p.x;
        y = p.y;
        z = p.z;
    }

    /**
     * Factory for a Point constructed from a Position
     *
     * @param p The Position
     * @return a Point representing the Position (units of millimeters)
     */
    public static Point fromPosition(Position p) {
        return new Point(p.getPositionX().doubleValue(pointUnits), p.getPositionY().doubleValue(pointUnits), p.getPositionZ().doubleValue(pointUnits));
    }

    /**
     * Reviews Point to determine if it is null. If Point is not null, review
     * all coordinates of the Point to ensure that none are infinity or
     * Not-A-Number (NaN).
     *
     * @param p Point to be tested
     * @return Boolean indicating whether Point is valid or not
     */
    public static boolean isValidPoint(Point p) {
        if (p == null || Double.isInfinite(p.x) || Double.isNaN(p.x)
                || Double.isInfinite(p.y) || Double.isNaN(p.y)
                || Double.isInfinite(p.z) || Double.isNaN(p.z)) {
            return false;
        }
        return true;
    }

    public void subtract(Point p) {
        this.x -= p.getX();
        this.y -= p.getY();
        this.z -= p.getZ();
    }

    public void subtract(Vector3 p) {
        this.x -= p.getX();
        this.y -= p.getY();
        this.z -= p.getZ();
    }

    /**
     * Create a Vector from the origin to this Point
     *
     * @return The new Vector object
     */
    public Vector3 toVector() {
        return new Vector3(x, y, z);
    }

    /**
     * Format a String representation of this point in the form "(x, y, z)"
     *
     * @return The output String
     */
    @Override
    public String toString() {
        return "(" + x + ", " + y + ", " + z + ")";
    }

    /**
     * Calculate the distance between this point and another point.
     *
     * @param p The other point
     * @return Distance between the points
     */
    public double dist(Point p) {
        if (p == null) {
            throw new IllegalArgumentException(
                    "Cannot calculate distance to a null Point");
        }
//        if (!isValidPoint(p)) {
//            throw new IllegalArgumentException(
//                    "Cannot calculate distance from Point with illegal coordinates");
//        }

        return sqrt(((x - p.x) * (x - p.x)) + ((y - p.y) * (y - p.y))
                + ((z - p.z) * (z - p.z)));
    }

    /**
     * Set the X coordinate of the Point
     *
     * @param x The value of the X coordinate
     */
    public void setX(double x) {
        if (Double.isInfinite(x) || Double.isNaN(x)) {
            throw new IllegalArgumentException(
                    "Cannot set Point coordinate to illegal value: " + x);
        }
        this.x = x;
    }

    /**
     * Set the Y coordinate of the Point
     *
     * @param y The value of the Y coordinate
     */
    public void setY(double y) {
        if (Double.isInfinite(y) || Double.isNaN(y)) {
            throw new IllegalArgumentException(
                    "Cannot set Point coordinate to illegal value: " + y);
        }
        this.y = y;
    }

    /**
     * Set the Z coordinate of the Point
     *
     * @param z The value of the Z coordinate
     */
    public void setZ(double z) {
        if (Double.isInfinite(z) || Double.isNaN(z)) {
            throw new IllegalArgumentException(
                    "Cannot set Point coordinate to illegal value: " + z);
        }
        this.z = z;
    }

    /**
     * Get the X coordinate of this Point
     *
     * @return The X coordinate of this Point
     */
    public double getX() {
        return (x);
    }

    /**
     * Get the Y coordinate of this Point
     *
     * @return The Y coordinate of this Point
     */
    public double getY() {
        return (y);
    }

    /**
     * Get the Z coordinate of this Point
     *
     * @return The Z coordinate of this Point
     */
    public double getZ() {
        return (z);
    }

    public double get( int index ) {
        switch( index ) {
            case 0:
                return x;
            case 1:
                return y;
            case 2:
                return z;
            default:
                throw new IllegalArgumentException( "get(int i) called with illegal argument (" + index + ") must be 0, 1, or 2" );
        }
    }

    public void set(int index, double d) {
        switch( index ) {
            case 0:
                this.x = d;
                break;
            case 1:
                this.y = d;
                break;
            case 2:
                this.z = d;
                break;
            default:
                throw new IllegalArgumentException( "set(int i) called with illegal argument (" + index + ") must be 0, 1, or 2" );
        }
    }

    /**
     * Add vector operation.
     *
     * @param v Vector to add.
     * @throws IllegalArgumentException if the argument is either null or any
     *                                  one of its coordinates is either NaN or Infinite.
     */
    public void plus(Vector3 v) {
        if (v == null) {
            throw new IllegalArgumentException("plus() called with null Vector");
        }
//        if (!Vector3.isValidVector(v)) {
//            throw new IllegalArgumentException(
//                    "plus() called with Vector containing NaN/Infinity coordinates");
//        }

        x += v.getX();
        y += v.getY();
        z += v.getZ();
    }

    /**
     * Add Point operation.
     *
     * @param v Point to add.
     * @throws IllegalArgumentException if the argument is either null or any
     *                                  one of its coordinates is either NaN or Infinite.
     */
    public void plus(Point v) {
        if (v == null) {
            throw new IllegalArgumentException("plus() called with null Vector");
        }
//        if (!Point.isValidPoint(v)) {
//            throw new IllegalArgumentException(
//                    "plus() called with Vector containing NaN/Infinity coordinates");
//        }

        x += v.getX();
        y += v.getY();
        z += v.getZ();
    }

    /**
     * Report the current tolerance (epsilon).
     *
     * @return The comparison tolerance for this Point
     */
    public double getTolerance() {
        return tolerance;
    }

    /**
     * Set the tolerance of this Point
     *
     * @param t Tolerance value to set
     */
    public void setTolerance(double t) {
        if (Double.isInfinite(t) || Double.isNaN(t)) {
            throw new IllegalArgumentException("Illegal value for tolerance: "
                    + t);
        }
        tolerance = abs(t);
    }

    /**
     * Test if two points are in the same place (within epsilon). The tolerance
     * aspect applies to half-edge length of a bounding box.
     *
     * @param p Point to compare against
     * @return Boolean indicating if the points are 'close' enough to call
     *         equal.
     */
    public boolean isEqual(Point p) {
        if (p == null || !isValidPoint(p)) {
            return false;
        }
        return (abs(p.x - x) < tolerance) && (abs(p.y - y) < tolerance)
                && (abs(p.z - z) < tolerance);
    }

    /**
     * Test if two points are in the same place (within epsilon). The tolerance
     * aspect applies to half-edge length of a bounding box.
     *
     * @param p1 Point to compare.
     * @param p2 Point to compare.
     * @return Boolean indicating if the points are 'close' enough to call
     *         equal.
     */
    public static boolean isEqual(Point p1, Point p2) {
        if (p1 == null && p2 == null) {
            return true;
        }
        if (p1 == null || p2 == null) {
            return false;
        }
        return p1.isEqual(p2);
    }

    /**
     * Test equality of points.
     *
     * @param o Object that may or may not be a point.
     * @return true if 'o' is a point and the points are in the same place,
     *         within the tolerance of 'this'.
     */
    @Override
    public boolean equals(Object o) {
        if (o instanceof Point) {
            return isEqual((Point) o);
        }
        return false;
    }

    /**
     * Implement hash calculation for this Point.
     *
     * @return An int which is the hashcode.
     */
    @Override
    public int hashCode() {

        int result;

        result = 7 * DoubleHash.hashCode(this.x);
        result = 13 * DoubleHash.hashCode(this.y) + result;
        result = 17 * DoubleHash.hashCode(this.z) + result;

        return result;
    }

    /**
     * Move this point by the amount specified by the supplied input Vector
     *
     * @param vector Input vector
     */
    public void translate(Vector3 vector) {
        if (vector == null) {
            throw new IllegalArgumentException(
                    "Cannot translate with a null translation vector");
        }
        if (!Vector3.isValidVector(vector)) {
            throw new IllegalArgumentException(
                    "Cannot translate using Vector3 with illegal coordinates");
        }

        x += vector.getX();
        y += vector.getY();
        z += vector.getZ();
    }

    /**
     * Scale this point by the amount specified by the supplied scaleFactor
     *
     * @param scaleFactor The supplied scaling factor
     */
    public void scale(double scaleFactor) {
        if (Double.isInfinite(scaleFactor) || Double.isNaN(scaleFactor)) {
            throw new IllegalArgumentException("Illegal value of scaleFactor: "
                    + scaleFactor);
        }
        x *= scaleFactor;
        y *= scaleFactor;
        z *= scaleFactor;
    }

    /**
     * Scale the Point by the Vector
     *
     * @param dist Distance
     * @param dir  Direction
     */
    public void join(double dist, Vector3 dir) {
        if (dir == null) {
            throw new IllegalArgumentException(
                    "Cannot join with a null direction vector");
        }
//        if (!Vector3.isValidVector(dir)) {
//            throw new IllegalArgumentException(
//                    "Cannot join using Vector3 with illegal coordinates");
//        }

        if (Double.isInfinite(dist) || Double.isNaN(dist)) {
            throw new IllegalArgumentException("Illegal value of dist: " + dist);
        }

        x += dist * dir.getX();
        y += dist * dir.getY();
        z += dist * dir.getZ();
    }

    /**
     * Rotate this vector around the specified up vector.
     *
     * @param upVector The up vector to perform rotation around.
     * @param angle    The angle (in degrees) to rotate the vector.
     * @throws IllegalArgumentException if the the vector is null, any one of
     *                                  the vector's coordinates is either NaN or Infinite, or the
     *                                  rotation angle is either NaN or Infinite.
     */
    public void rotate(Vector3 upVector, double angle) {
        if (upVector == null) {
            throw new IllegalArgumentException(
                    "rotate() called with null upVector");
        }
//        if (!Vector3.isValidVector(upVector)) {
//            throw new IllegalArgumentException(
//                    "rotate() called with upVector containing NaN/Infinity coordinates");
//        }

        if (Double.isInfinite(angle) || Double.isNaN(angle)) {
            throw new IllegalArgumentException(
                    "rotate() called with illegal angle: " + angle);
        }

        // create basis vectors with upVector as one of the directions
        Vector3 v3 = new Vector3(upVector);
        v3.normalize();

        Vector3 v0 = this.toVector();
        Vector3 v1 = v0.crossProduct(v3);
        v1.normalize();

        if (Double.isNaN(v1.getX()) || Double.isNaN(v1.getY())
                || Double.isNaN(v1.getZ())) {
            // this vector is parallel to the upvector, no need to change it
            return;
        }

        Vector3 v2 = Vector3.crossProduct(v3, v1);
        v2.normalize();

        double radians = angle / 180.0 * java.lang.Math.PI;
        double sine = Math.sin(radians);
        double cosine = Math.cos(radians);

        double x1 = v0.dotProduct(v1);
        double y1 = v0.dotProduct(v2);
        double z1 = v0.dotProduct(v3);

        double x2 = x1 * cosine - y1 * sine;
        double y2 = x1 * sine + y1 * cosine;

        this.x = 0.0;
        this.y = 0.0;
        this.z = 0.0;

        this.join(x2, v1);
        this.join(y2, v2);
        this.join(z1, v3);
    }
}
